//! Implements unique id generation node using [main].
use std::io::{stdin, stdout};

use gossip_glomers::{
    derive_request, derive_response,
    init::{init, InitRequest},
    message::{Body, Message},
};

derive_request!(
    /// Request payload for unique id generation node.
    pub enum GenRequest {
        /// Generate Id request.
        ///
        /// This message requests node to generate unique id.
        /// ```json
        /// { "type": "generate" }
        /// ```
        Generate,
    }
);

derive_response!(
    /// Response payload for unique id generation node.
    pub enum GenRespone {
        /// Generate ok response.
        ///
        /// This message acknowledges Generate request.
        /// It includes the uniquely generated Id.
        /// ```json
        /// {
        ///     "type": "generate_ok",
        ///     "id": 123
        /// }
        /// ```
        GenerateOk {
            /// Newly generated id.
            id: usize,
        },
    }
);

/// Unique Id generation node entry point.
///
/// The unique id server.
/// * Handle Initialization Protocol using [init].
/// * Read standard input for [Request][GenRequest::Generate]
///   and reply with [Response][GenRespone::GenerateOk].
///
/// # Logic
///
/// `unique_id = node_id + node_count * counter`
///
/// Hence
/// * `unique_id % node_count = node_id`
///   which means the ids generated by two node cannot collide
/// * `unique_id - node_id = node_count * counter`
///   as counter is updated after each message sent, id generated by a node don't collide.
fn main() {
    let stdin = stdin().lock();
    let mut deseralizer = serde_json::Deserializer::from_reader(stdin);
    let mut stdout = stdout().lock();
    let (node_id, node_count) = match init(&mut stdout, &mut deseralizer) {
        InitRequest::Init {
            node_id,
            mut node_ids,
        } => {
            node_ids.sort();
            let node_pos = node_ids.iter().position(|n| n.eq(&node_id)).unwrap();
            (node_pos, node_ids.len())
        }
    };
    for (counter, request) in deseralizer.into_iter::<Message<_>>().flatten().enumerate() {
        match request.body.payload {
            GenRequest::Generate => Message {
                src: request.dst,
                dst: request.src,
                body: Body {
                    id: Some(counter),
                    reply_id: request.body.id,
                    payload: GenRespone::GenerateOk {
                        id: node_id + counter * node_count,
                    },
                },
            },
        }
        .send(&mut stdout);
    }
}
